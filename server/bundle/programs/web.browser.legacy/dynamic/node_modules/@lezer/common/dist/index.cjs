function(e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=1024;let n=0;class i{constructor(e,t){this.from=e,this.to=t}}class s{constructor(e={}){this.id=n++,this.perNode=!!e.perNode,this.deserialize=e.deserialize||(()=>{throw new Error("This node type doesn't define a deserialize function")})}add(e){if(this.perNode)throw new RangeError("Can't add per-node props to node types");return"function"!=typeof e&&(e=f.match(e)),t=>{let r=e(t);return void 0===r?null:[this,r]}}}s.closedBy=new s({deserialize:e=>e.split(" ")}),s.openedBy=new s({deserialize:e=>e.split(" ")}),s.group=new s({deserialize:e=>e.split(" ")}),s.contextHash=new s({perNode:!0}),s.lookAhead=new s({perNode:!0}),s.mounted=new s({perNode:!0});class o{constructor(e,t,r){this.tree=e,this.overlay=t,this.parser=r}}const h=Object.create(null);class f{constructor(e,t,r,n=0){this.name=e,this.props=t,this.id=r,this.flags=n}static define(e){let t=e.props&&e.props.length?Object.create(null):h,r=(e.top?1:0)|(e.skipped?2:0)|(e.error?4:0)|(null==e.name?8:0),n=new f(e.name||"",t,e.id,r);if(e.props)for(let i of e.props)if(Array.isArray(i)||(i=i(n)),i){if(i[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");t[i[0].id]=i[1]}return n}prop(e){return this.props[e.id]}get isTop(){return(1&this.flags)>0}get isSkipped(){return(2&this.flags)>0}get isError(){return(4&this.flags)>0}get isAnonymous(){return(8&this.flags)>0}is(e){if("string"==typeof e){if(this.name==e)return!0;let t=this.prop(s.group);return!!t&&t.indexOf(e)>-1}return this.id==e}static match(e){let t=Object.create(null);for(let r in e)for(let n of r.split(" "))t[n]=e[r];return e=>{for(let r=e.prop(s.group),n=-1;n<(r?r.length:0);n++){let i=t[n<0?e.name:r[n]];if(i)return i}}}}f.none=new f("",Object.create(null),0,8);class l{constructor(e){this.types=e;for(let t=0;t<e.length;t++)if(e[t].id!=t)throw new RangeError("Node type ids should correspond to array positions when creating a node set")}extend(...e){let t=[];for(let r of this.types){let n=null;for(let t of e){let e=t(r);e&&(n||(n=Object.assign({},r.props)),n[e[0].id]=e[1])}t.push(n?new f(r.name,n,r.id,r.flags):r)}return new l(t)}}const u=new WeakMap,a=new WeakMap;var d;t.IterMode=void 0,(d=t.IterMode||(t.IterMode={}))[d.ExcludeBuffers=1]="ExcludeBuffers",d[d.IncludeAnonymous=2]="IncludeAnonymous",d[d.IgnoreMounts=4]="IgnoreMounts",d[d.IgnoreOverlays=8]="IgnoreOverlays";class p{constructor(e,t,r,n,i){if(this.type=e,this.children=t,this.positions=r,this.length=n,this.props=null,i&&i.length){this.props=Object.create(null);for(let[e,t]of i)this.props["number"==typeof e?e:e.id]=t}}toString(){let e=this.prop(s.mounted);if(e&&!e.overlay)return e.tree.toString();let t="";for(let r of this.children){let e=r.toString();e&&(t&&(t+=","),t+=e)}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):this.type.name)+(t.length?"("+t+")":""):t}cursor(e=0){return new I(this.topNode,e)}cursorAt(e,t=0,r=0){let n=u.get(this)||this.topNode,i=new I(n);return i.moveTo(e,t),u.set(this,i._tree),i}get topNode(){return new y(this,0,0,null)}resolve(e,t=0){let r=x(u.get(this)||this.topNode,e,t,!1);return u.set(this,r),r}resolveInner(e,t=0){let r=x(a.get(this)||this.topNode,e,t,!0);return a.set(this,r),r}iterate(e){let{enter:r,leave:n,from:i=0,to:s=this.length}=e;for(let o=this.cursor((e.mode||0)|t.IterMode.IncludeAnonymous);;){let e=!1;if(o.from<=s&&o.to>=i&&(o.type.isAnonymous||!1!==r(o))){if(o.firstChild())continue;e=!0}for(;e&&n&&!o.type.isAnonymous&&n(o),!o.nextSibling();){if(!o.parent())return;e=!0}}}prop(e){return e.perNode?this.props?this.props[e.id]:void 0:this.type.prop(e)}get propValues(){let e=[];if(this.props)for(let t in this.props)e.push([+t,this.props[t]]);return e}balance(e={}){return this.children.length<=8?this:N(f.none,this.children,this.positions,0,this.children.length,0,this.length,(e,t,r)=>new p(this.type,e,t,r,this.propValues),e.makeTree||((e,t,r)=>new p(f.none,e,t,r)))}static build(e){return k(e)}}p.empty=new p(f.none,[],[],0);class c{constructor(e,t){this.buffer=e,this.index=t}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new c(this.buffer,this.index)}}class g{constructor(e,t,r){this.buffer=e,this.length=t,this.set=r}get type(){return f.none}toString(){let e=[];for(let t=0;t<this.buffer.length;)e.push(this.childString(t)),t=this.buffer[t+3];return e.join(",")}childString(e){let t=this.buffer[e],r=this.buffer[e+3],n=this.set.types[t],i=n.name;if(/\W/.test(i)&&!n.isError&&(i=JSON.stringify(i)),r==(e+=4))return i;let s=[];for(;e<r;)s.push(this.childString(e)),e=this.buffer[e+3];return i+"("+s.join(",")+")"}findChild(e,t,r,n,i){let{buffer:s}=this,o=-1;for(let h=e;h!=t&&!(m(i,n,s[h+1],s[h+2])&&(o=h,r>0));h=s[h+3]);return o}slice(e,t,r,n){let i=this.buffer,s=new Uint16Array(t-e);for(let o=e,h=0;o<t;)s[h++]=i[o++],s[h++]=i[o++]-r,s[h++]=i[o++]-r,s[h++]=i[o++]-e;return new g(s,n-r,this.set)}}function m(e,t,r,n){switch(e){case-2:return r<t;case-1:return n>=t&&r<t;case 0:return r<t&&n>t;case 1:return r<=t&&n>t;case 2:return n>t;case 4:return!0}}function b(e,t){let r=e.childBefore(t);for(;r;){let t=r.lastChild;if(!t||t.to!=r.to)break;t.type.isError&&t.from==t.to?(e=r,r=t.prevSibling):r=t}return e}function x(e,r,n,i){for(var s;e.from==e.to||(n<1?e.from>=r:e.from>r)||(n>-1?e.to<=r:e.to<r);){let t=!i&&e instanceof y&&e.index<0?null:e.parent;if(!t)return e;e=t}let o=i?0:t.IterMode.IgnoreOverlays;if(i)for(let t=e,h=t.parent;h;h=(t=h).parent)t instanceof y&&t.index<0&&(null===(s=h.enter(r,n,o))||void 0===s?void 0:s.from)!=t.from&&(e=h);for(;;){let t=e.enter(r,n,o);if(!t)return e;e=t}}class y{constructor(e,t,r,n){this._tree=e,this.from=t,this.index=r,this._parent=n}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(e,r,n,i,o=0){for(let h=this;;){for(let{children:f,positions:l}=h._tree,u=r>0?f.length:-1;e!=u;e+=r){let u=f[e],a=l[e]+h.from;if(m(i,n,a,a+u.length))if(u instanceof g){if(o&t.IterMode.ExcludeBuffers)continue;let s=u.findChild(0,u.buffer.length,r,n-a,i);if(s>-1)return new A(new _(h,u,e,a),null,s)}else if(o&t.IterMode.IncludeAnonymous||!u.type.isAnonymous||C(u)){let f;if(!(o&t.IterMode.IgnoreMounts)&&u.props&&(f=u.prop(s.mounted))&&!f.overlay)return new y(f.tree,a,e,h);let l=new y(u,a,e,h);return o&t.IterMode.IncludeAnonymous||!l.type.isAnonymous?l:l.nextChild(r<0?u.children.length-1:0,r,n,i)}}if(o&t.IterMode.IncludeAnonymous||!h.type.isAnonymous)return null;if(e=h.index>=0?h.index+r:r<0?-1:h._parent._tree.children.length,!(h=h._parent))return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(e){return this.nextChild(0,1,e,2)}childBefore(e){return this.nextChild(this._tree.children.length-1,-1,e,-2)}enter(e,r,n=0){let i;if(!(n&t.IterMode.IgnoreOverlays)&&(i=this._tree.prop(s.mounted))&&i.overlay){let t=e-this.from;for(let{from:e,to:n}of i.overlay)if((r>0?e<=t:e<t)&&(r<0?n>=t:n>t))return new y(i.tree,i.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,e,r,n)}nextSignificantParent(){let e=this;for(;e.type.isAnonymous&&e._parent;)e=e._parent;return e}get parent(){return this._parent?this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&this.index>=0?this._parent.nextChild(this.index-1,-1,0,4):null}cursor(e=0){return new I(this,e)}get tree(){return this._tree}toTree(){return this._tree}resolve(e,t=0){return x(this,e,t,!1)}resolveInner(e,t=0){return x(this,e,t,!0)}enterUnfinishedNodesBefore(e){return b(this,e)}getChild(e,t=null,r=null){let n=w(this,e,t,r);return n.length?n[0]:null}getChildren(e,t=null,r=null){return w(this,e,t,r)}toString(){return this._tree.toString()}get node(){return this}matchContext(e){return v(this,e)}}function w(e,t,r,n){let i=e.cursor(),s=[];if(!i.firstChild())return s;if(null!=r)for(;!i.type.is(r);)if(!i.nextSibling())return s;for(;;){if(null!=n&&i.type.is(n))return s;if(i.type.is(t)&&s.push(i.node),!i.nextSibling())return null==n?s:[]}}function v(e,t,r=t.length-1){for(let n=e.parent;r>=0;n=n.parent){if(!n)return!1;if(!n.type.isAnonymous){if(t[r]&&t[r]!=n.name)return!1;r--}}return!0}class _{constructor(e,t,r,n){this.parent=e,this.buffer=t,this.index=r,this.start=n}}class A{constructor(e,t,r){this.context=e,this._parent=t,this.index=r,this.type=e.buffer.set.types[e.buffer.buffer[r]]}get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}child(e,t,r){let{buffer:n}=this.context,i=n.findChild(this.index+4,n.buffer[this.index+3],e,t-this.context.start,r);return i<0?null:new A(this.context,this,i)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(e){return this.child(1,e,2)}childBefore(e){return this.child(-1,e,-2)}enter(e,r,n=0){if(n&t.IterMode.ExcludeBuffers)return null;let{buffer:i}=this.context,s=i.findChild(this.index+4,i.buffer[this.index+3],r>0?1:-1,e-this.context.start,r);return s<0?null:new A(this.context,this,s)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(e){return this._parent?null:this.context.parent.nextChild(this.context.index+e,e,0,4)}get nextSibling(){let{buffer:e}=this.context,t=e.buffer[this.index+3];return t<(this._parent?e.buffer[this._parent.index+3]:e.buffer.length)?new A(this.context,this._parent,t):this.externalSibling(1)}get prevSibling(){let{buffer:e}=this.context,t=this._parent?this._parent.index+4:0;return this.index==t?this.externalSibling(-1):new A(this.context,this._parent,e.findChild(t,this.index,-1,0,4))}cursor(e=0){return new I(this,e)}get tree(){return null}toTree(){let e=[],t=[],{buffer:r}=this.context,n=this.index+4,i=r.buffer[this.index+3];if(i>n){let s=r.buffer[this.index+1],o=r.buffer[this.index+2];e.push(r.slice(n,i,s,o)),t.push(0)}return new p(this.type,e,t,this.to-this.from)}resolve(e,t=0){return x(this,e,t,!1)}resolveInner(e,t=0){return x(this,e,t,!0)}enterUnfinishedNodesBefore(e){return b(this,e)}toString(){return this.context.buffer.childString(this.index)}getChild(e,t=null,r=null){let n=w(this,e,t,r);return n.length?n[0]:null}getChildren(e,t=null,r=null){return w(this,e,t,r)}get node(){return this}matchContext(e){return v(this,e)}}class I{constructor(e,t=0){if(this.mode=t,this.buffer=null,this.stack=[],this.index=0,this.bufferNode=null,e instanceof y)this.yieldNode(e);else{this._tree=e.context.parent,this.buffer=e.context;for(let t=e._parent;t;t=t._parent)this.stack.unshift(t.index);this.bufferNode=e,this.yieldBuf(e.index)}}get name(){return this.type.name}yieldNode(e){return!!e&&(this._tree=e,this.type=e.type,this.from=e.from,this.to=e.to,!0)}yieldBuf(e,t){this.index=e;let{start:r,buffer:n}=this.buffer;return this.type=t||n.set.types[n.buffer[e]],this.from=r+n.buffer[e+1],this.to=r+n.buffer[e+2],!0}yield(e){return!!e&&(e instanceof y?(this.buffer=null,this.yieldNode(e)):(this.buffer=e.context,this.yieldBuf(e.index,e.type)))}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(e,t,r){if(!this.buffer)return this.yield(this._tree.nextChild(e<0?this._tree._tree.children.length-1:0,e,t,r,this.mode));let{buffer:n}=this.buffer,i=n.findChild(this.index+4,n.buffer[this.index+3],e,t-this.buffer.start,r);return!(i<0)&&(this.stack.push(this.index),this.yieldBuf(i))}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(e){return this.enterChild(1,e,2)}childBefore(e){return this.enterChild(-1,e,-2)}enter(e,r,n=this.mode){return this.buffer?!(n&t.IterMode.ExcludeBuffers)&&this.enterChild(1,e,r):this.yield(this._tree.enter(e,r,n))}parent(){if(!this.buffer)return this.yieldNode(this.mode&t.IterMode.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let e=this.mode&t.IterMode.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();return this.buffer=null,this.yieldNode(e)}sibling(e){if(!this.buffer)return!!this._tree._parent&&this.yield(this._tree.index<0?null:this._tree._parent.nextChild(this._tree.index+e,e,0,4,this.mode));let{buffer:t}=this.buffer,r=this.stack.length-1;if(e<0){let e=r<0?0:this.stack[r]+4;if(this.index!=e)return this.yieldBuf(t.findChild(e,this.index,-1,0,4))}else{let e=t.buffer[this.index+3];if(e<(r<0?t.buffer.length:t.buffer[this.stack[r]+3]))return this.yieldBuf(e)}return r<0&&this.yield(this.buffer.parent.nextChild(this.buffer.index+e,e,0,4,this.mode))}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(e){let r,n,{buffer:i}=this;if(i){if(e>0){if(this.index<i.buffer.buffer.length)return!1}else for(let e=0;e<this.index;e++)if(i.buffer.buffer[e+3]<this.index)return!1;({index:r,parent:n}=i)}else({index:r,_parent:n}=this._tree);for(;n;({index:r,_parent:n}=n))if(r>-1)for(let i=r+e,s=e<0?-1:n._tree.children.length;i!=s;i+=e){let e=n._tree.children[i];if(this.mode&t.IterMode.IncludeAnonymous||e instanceof g||!e.type.isAnonymous||C(e))return!1}return!0}move(e,t){if(t&&this.enterChild(e,0,4))return!0;for(;;){if(this.sibling(e))return!0;if(this.atLastNode(e)||!this.parent())return!1}}next(e=!0){return this.move(1,e)}prev(e=!0){return this.move(-1,e)}moveTo(e,t=0){for(;(this.from==this.to||(t<1?this.from>=e:this.from>e)||(t>-1?this.to<=e:this.to<e))&&this.parent(););for(;this.enterChild(1,e,t););return this}get node(){if(!this.buffer)return this._tree;let e=this.bufferNode,t=null,r=0;if(e&&e.context==this.buffer)e:for(let n=this.index,i=this.stack.length;i>=0;){for(let s=e;s;s=s._parent)if(s.index==n){if(n==this.index)return s;t=s,r=i+1;break e}n=this.stack[--i]}for(let n=r;n<this.stack.length;n++)t=new A(this.buffer,t,this.stack[n]);return this.bufferNode=new A(this.buffer,t,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(e,t){for(let r=0;;){let n=!1;if(this.type.isAnonymous||!1!==e(this)){if(this.firstChild()){r++;continue}this.type.isAnonymous||(n=!0)}for(;n&&t&&t(this),n=this.type.isAnonymous,!this.nextSibling();){if(!r)return;this.parent(),r--,n=!0}}}matchContext(e){if(!this.buffer)return v(this.node,e);let{buffer:t}=this.buffer,{types:r}=t.set;for(let n=e.length-1,i=this.stack.length-1;n>=0;i--){if(i<0)return v(this.node,e,n);let s=r[t.buffer[this.stack[i]]];if(!s.isAnonymous){if(e[n]&&e[n]!=s.name)return!1;n--}}return!0}}function C(e){return e.children.some(e=>e instanceof g||!e.type.isAnonymous||C(e))}function k(e){var t;let{buffer:n,nodeSet:i,maxBufferLength:o=r,reused:h=[],minRepeatType:f=i.types.length}=e,l=Array.isArray(n)?new c(n,n.length):n,u=i.types,a=0,d=0;function m(e,t,r,n,s){let{id:p,start:c,end:_,size:A}=l,I=d;for(;A<0;){if(l.next(),-1==A){let t=h[p];return r.push(t),void n.push(c-e)}if(-3==A)return void(a=p);if(-4==A)return void(d=p);throw new RangeError(`Unrecognized record size: ${A}`)}let C=u[p],k,M,S=c-e;if(_-c<=o&&(M=w(l.pos-t,s))){let t=new Uint16Array(M.size-M.skip),r=l.pos-M.size,n=t.length;for(;l.pos>r;)n=v(M.start,t,n);k=new g(t,_-M.start,i),S=M.start-e}else{let e=l.pos-A;l.next();let t=[],r=[],n=p>=f?p:-1,i=0,s=_;for(;l.pos>e;)n>=0&&l.id==n&&l.size>=0?(l.end<=s-o&&(x(t,r,c,i,l.end,s,n,I),i=t.length,s=l.end),l.next()):m(c,e,t,r,n);if(n>=0&&i>0&&i<t.length&&x(t,r,c,i,c,s,n,I),t.reverse(),r.reverse(),n>-1&&i>0){let e=b(C);k=N(C,t,r,0,t.length,0,_-c,e,e)}else k=y(C,t,r,_-c,I-_)}r.push(k),n.push(S)}function b(e){return(t,r,n)=>{let i=0,o=t.length-1,h,f;if(o>=0&&(h=t[o])instanceof p){if(!o&&h.type==e&&h.length==n)return h;(f=h.prop(s.lookAhead))&&(i=r[o]+h.length+f)}return y(e,t,r,n,i)}}function x(e,t,r,n,s,o,h,f){let l=[],u=[];for(;e.length>n;)l.push(e.pop()),u.push(t.pop()+r-s);e.push(y(i.types[h],l,u,o-s,f-o)),t.push(s-r)}function y(e,t,r,n,i=0,o){if(a){let e=[s.contextHash,a];o=o?[e].concat(o):[e]}if(i>25){let e=[s.lookAhead,i];o=o?[e].concat(o):[e]}return new p(e,t,r,n,o)}function w(e,t){let r=l.fork(),n=0,i=0,s=0,h=r.end-o,u={size:0,start:0,skip:0};e:for(let o=r.pos-e;r.pos>o;){let e=r.size;if(r.id==t&&e>=0){u.size=n,u.start=i,u.skip=s,s+=4,n+=4,r.next();continue}let l=r.pos-e;if(e<0||l<o||r.start<h)break;let a=r.id>=f?4:0,d=r.start;for(r.next();r.pos>l;){if(r.size<0){if(-3!=r.size)break e;a+=4}else r.id>=f&&(a+=4);r.next()}i=d,n+=e,s+=a}return(t<0||n==e)&&(u.size=n,u.start=i,u.skip=s),u.size>4?u:void 0}function v(e,t,r){let{id:n,start:i,end:s,size:o}=l;if(l.next(),o>=0&&n<f){let h=r;if(o>4){let n=l.pos-(o-4);for(;l.pos>n;)r=v(e,t,r)}t[--r]=h,t[--r]=s-e,t[--r]=i-e,t[--r]=n}else-3==o?a=n:-4==o&&(d=n);return r}let _=[],A=[];for(;l.pos>0;)m(e.start||0,e.bufferStart||0,_,A,-1);let I=null!==(t=e.length)&&void 0!==t?t:_.length?A[0]+_[0].length:0;return new p(u[e.topID],_.reverse(),A.reverse(),I)}const M=new WeakMap;function S(e,t){if(!e.isAnonymous||t instanceof g||t.type!=e)return 1;let r=M.get(t);if(null==r){r=1;for(let n of t.children){if(n.type!=e||!(n instanceof p)){r=1;break}r+=S(e,n)}M.set(t,r)}return r}function N(e,t,r,n,i,s,o,h,f){let l=0;for(let c=n;c<i;c++)l+=S(e,t[c]);let u=Math.ceil(1.5*l/8),a=[],d=[];function p(t,r,n,i,o){for(let h=n;h<i;){let n=h,l=r[h],c=S(e,t[h]);for(h++;h<i;h++){let r=S(e,t[h]);if(c+r>=u)break;c+=r}if(h==n+1){if(c>u){let e=t[n];p(e.children,e.positions,0,e.children.length,r[n]+o);continue}a.push(t[n])}else{let i=r[h-1]+t[h-1].length-l;a.push(N(e,t,r,n,h,l,i,null,f))}d.push(l+o-s)}}return p(t,r,n,i,0),(h||f)(a,d,o)}class B{constructor(){this.map=new WeakMap}setBuffer(e,t,r){let n=this.map.get(e);n||this.map.set(e,n=new Map),n.set(t,r)}getBuffer(e,t){let r=this.map.get(e);return r&&r.get(t)}set(e,t){e instanceof A?this.setBuffer(e.context.buffer,e.index,t):e instanceof y&&this.map.set(e.tree,t)}get(e){return e instanceof A?this.getBuffer(e.context.buffer,e.index):e instanceof y?this.map.get(e.tree):void 0}cursorSet(e,t){e.buffer?this.setBuffer(e.buffer.buffer,e.index,t):this.map.set(e.tree,t)}cursorGet(e){return e.buffer?this.getBuffer(e.buffer.buffer,e.index):this.map.get(e.tree)}}class T{constructor(e,t,r,n,i=!1,s=!1){this.from=e,this.to=t,this.tree=r,this.offset=n,this.open=(i?1:0)|(s?2:0)}get openStart(){return(1&this.open)>0}get openEnd(){return(2&this.open)>0}static addTree(e,t=[],r=!1){let n=[new T(0,e.length,e,0,!1,r)];for(let i of t)i.to>e.length&&n.push(i);return n}static applyChanges(e,t,r=128){if(!t.length)return e;let n=[],i=1,s=e.length?e[0]:null;for(let o=0,h=0,f=0;;o++){let l=o<t.length?t[o]:null,u=l?l.fromA:1e9;if(u-h>=r)for(;s&&s.from<u;){let t=s;if(h>=t.from||u<=t.to||f){let e=Math.max(t.from,h)-f,r=Math.min(t.to,u)-f;t=e>=r?null:new T(e,r,t.tree,t.offset+f,o>0,!!l)}if(t&&n.push(t),s.to>u)break;s=i<e.length?e[i++]:null}if(!l)break;h=l.toA,f=l.toA-l.toB}return n}}class z{startParse(e,t,r){return"string"==typeof e&&(e=new P(e)),r=r?r.length?r.map(e=>new i(e.from,e.to)):[new i(0,0)]:[new i(0,e.length)],this.createParse(e,t||[],r)}parse(e,t,r){let n=this.startParse(e,t,r);for(;;){let e=n.advance();if(e)return e}}}class P{constructor(e){this.string=e}get length(){return this.string.length}chunk(e){return this.string.slice(e)}get lineChunks(){return!1}read(e,t){return this.string.slice(e,t)}}function O(e){return(t,r,n,i)=>new D(t,e,r,n,i)}class E{constructor(e,t,r,n,i){this.parser=e,this.parse=t,this.overlay=r,this.target=n,this.ranges=i}}class j{constructor(e,t,r,n,i,s,o){this.parser=e,this.predicate=t,this.mounts=r,this.index=n,this.start=i,this.target=s,this.prev=o,this.depth=0,this.ranges=[]}}const F=new s({perNode:!0});class D{constructor(e,t,r,n,i){this.nest=t,this.input=r,this.fragments=n,this.ranges=i,this.inner=[],this.innerDone=0,this.baseTree=null,this.stoppedAt=null,this.baseParse=e}advance(){if(this.baseParse){let e=this.baseParse.advance();if(!e)return null;if(this.baseParse=null,this.baseTree=e,this.startInner(),null!=this.stoppedAt)for(let t of this.inner)t.parse.stopAt(this.stoppedAt)}if(this.innerDone==this.inner.length){let e=this.baseTree;return null!=this.stoppedAt&&(e=new p(e.type,e.children,e.positions,e.length,e.propValues.concat([[F,this.stoppedAt]]))),e}let e=this.inner[this.innerDone],t=e.parse.advance();if(t){this.innerDone++;let r=Object.assign(Object.create(null),e.target.props);r[s.mounted.id]=new o(t,e.overlay,e.parser),e.target.props=r}return null}get parsedPos(){if(this.baseParse)return 0;let e=this.input.length;for(let t=this.innerDone;t<this.inner.length;t++)this.inner[t].ranges[0].from<e&&(e=Math.min(e,this.inner[t].parse.parsedPos));return e}stopAt(e){if(this.stoppedAt=e,this.baseParse)this.baseParse.stopAt(e);else for(let t=this.innerDone;t<this.inner.length;t++)this.inner[t].parse.stopAt(e)}startInner(){let e=new J(this.fragments),r=null,n=null,s=new I(new y(this.baseTree,this.ranges[0].from,0,null),t.IterMode.IncludeAnonymous|t.IterMode.IgnoreMounts);e:for(let t,o;null==this.stoppedAt||s.from<this.stoppedAt;){let h=!0,f;if(e.hasNode(s)){if(r){let e=r.mounts.find(e=>e.frag.from<=s.from&&e.frag.to>=s.to&&e.mount.overlay);if(e)for(let t of e.mount.overlay){let n=t.from+e.pos,i=t.to+e.pos;n>=s.from&&i<=s.to&&!r.ranges.some(e=>e.from<i&&e.to>n)&&r.ranges.push({from:n,to:i})}}h=!1}else if(n&&(o=W(n.ranges,s.from,s.to)))h=2!=o;else if(!s.type.isAnonymous&&s.from<s.to&&(t=this.nest(s,this.input))){s.tree||U(s);let o=e.findMounts(s.from,t.parser);if("function"==typeof t.overlay)r=new j(t.parser,t.overlay,o,this.inner.length,s.from,s.tree,r);else{let e=V(this.ranges,t.overlay||[new i(s.from,s.to)]);e.length&&this.inner.push(new E(t.parser,t.parser.startParse(this.input,G(o,e),e),t.overlay?t.overlay.map(e=>new i(e.from-s.from,e.to-s.from)):null,s.tree,e)),t.overlay?e.length&&(n={ranges:e,depth:0,prev:n}):h=!1}}else r&&(f=r.predicate(s))&&(!0===f&&(f=new i(s.from,s.to)),f.from<f.to&&r.ranges.push(f));if(h&&s.firstChild())r&&r.depth++,n&&n.depth++;else for(;!s.nextSibling();){if(!s.parent())break e;if(r&&!--r.depth){let e=V(this.ranges,r.ranges);e.length&&this.inner.splice(r.index,0,new E(r.parser,r.parser.startParse(this.input,G(r.mounts,e),e),r.ranges.map(e=>new i(e.from-r.start,e.to-r.start)),r.target,e)),r=r.prev}n&&!--n.depth&&(n=n.prev)}}}}function W(e,t,r){for(let n of e){if(n.from>=r)break;if(n.to>t)return n.from<=t&&n.to>=r?2:1}return 0}function R(e,t,r,n,i,s){if(t<r){let o=e.buffer[t+1],h=e.buffer[r-2];n.push(e.slice(t,r,o,h)),i.push(o-s)}}function U(e){let{node:t}=e,r=0;do{e.parent(),r++}while(!e.tree);let n=0,i=e.tree,s=0;for(;!((s=i.positions[n]+e.from)<=t.from&&s+i.children[n].length>=t.to);n++);let o=i.children[n],h=o.buffer;function l(e,r,n,i,f){let u=e;for(;h[u+2]+s<=t.from;)u=h[u+3];let a=[],d=[];R(o,e,u,a,d,i);let c=h[u+1],g=h[u+2],m=c+s==t.from&&g+s==t.to&&h[u]==t.type.id;return a.push(m?t.toTree():l(u+4,h[u+3],o.set.types[h[u]],c,g-c)),d.push(c-i),R(o,h[u+3],r,a,d,i),new p(n,a,d,f)}i.children[n]=l(0,h.length,f.none,0,o.length);for(let f=0;f<=r;f++)e.childAfter(t.from)}class L{constructor(e,r){this.offset=r,this.done=!1,this.cursor=e.cursor(t.IterMode.IncludeAnonymous|t.IterMode.IgnoreMounts)}moveTo(e){let{cursor:r}=this,n=e-this.offset;for(;!this.done&&r.from<n;)r.to>=e&&r.enter(n,1,t.IterMode.IgnoreOverlays|t.IterMode.ExcludeBuffers)||r.next(!1)||(this.done=!0)}hasNode(e){if(this.moveTo(e.from),!this.done&&this.cursor.from+this.offset==e.from&&this.cursor.tree)for(let t=this.cursor.tree;;){if(t==e.tree)return!0;if(!(t.children.length&&0==t.positions[0]&&t.children[0]instanceof p))break;t=t.children[0]}return!1}}class J{constructor(e){var t;if(this.fragments=e,this.curTo=0,this.fragI=0,e.length){let r=this.curFrag=e[0];this.curTo=null!==(t=r.tree.prop(F))&&void 0!==t?t:r.to,this.inner=new L(r.tree,-r.offset)}else this.curFrag=this.inner=null}hasNode(e){for(;this.curFrag&&e.from>=this.curTo;)this.nextFrag();return this.curFrag&&this.curFrag.from<=e.from&&this.curTo>=e.to&&this.inner.hasNode(e)}nextFrag(){var e;if(this.fragI++,this.fragI==this.fragments.length)this.curFrag=this.inner=null;else{let t=this.curFrag=this.fragments[this.fragI];this.curTo=null!==(e=t.tree.prop(F))&&void 0!==e?e:t.to,this.inner=new L(t.tree,-t.offset)}}findMounts(e,t){var r;let n=[];if(this.inner){this.inner.cursor.moveTo(e,1);for(let e=this.inner.cursor.node;e;e=e.parent){let i=null===(r=e.tree)||void 0===r?void 0:r.prop(s.mounted);if(i&&i.parser==t)for(let t=this.fragI;t<this.fragments.length;t++){let r=this.fragments[t];if(r.from>=e.to)break;r.tree==this.curFrag.tree&&n.push({frag:r,pos:e.from-r.offset,mount:i})}}}return n}}function V(e,t){let r=null,n=t;for(let s=1,o=0;s<e.length;s++){let h=e[s-1].to,f=e[s].from;for(;o<n.length;o++){let e=n[o];if(e.from>=f)break;e.to<=h||(r||(n=r=t.slice()),e.from<h?(r[o]=new i(e.from,h),e.to>f&&r.splice(o+1,0,new i(f,e.to))):e.to>f?r[o--]=new i(f,e.to):r.splice(o--,1))}}return n}function H(e,t,r,n){let s=0,o=0,h=!1,f=!1,l=-1e9,u=[];for(;;){let a=s==e.length?1e9:h?e[s].to:e[s].from,d=o==t.length?1e9:f?t[o].to:t[o].from;if(h!=f){let e=Math.max(l,r),t=Math.min(a,d,n);e<t&&u.push(new i(e,t))}if(1e9==(l=Math.min(a,d)))break;a==l&&(h?(h=!1,s++):h=!0),d==l&&(f?(f=!1,o++):f=!0)}return u}function G(e,t){let r=[];for(let{pos:n,mount:s,frag:o}of e){let e=n+(s.overlay?s.overlay[0].from:0),h=e+s.tree.length,f=Math.max(o.from,e),l=Math.min(o.to,h);if(s.overlay){let h,u=H(t,s.overlay.map(e=>new i(e.from+n,e.to+n)),f,l);for(let t=0,n=f;;t++){let i=t==u.length,h=i?l:u[t].from;if(h>n&&r.push(new T(n,h,s.tree,-e,o.from>=n,o.to<=h)),i)break;n=u[t].to}}else r.push(new T(f,l,s.tree,-e,o.from>=e,o.to<=h))}return r}t.DefaultBufferLength=r,t.MountedTree=o,t.NodeProp=s,t.NodeSet=l,t.NodeType=f,t.NodeWeakMap=B,t.Parser=z,t.Tree=p,t.TreeBuffer=g,t.TreeCursor=I,t.TreeFragment=T,t.parseMixed=O}

